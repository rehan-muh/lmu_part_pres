##############################
# Among-Site Rate Variation####
###############################
# alpha is the shape parameter; the higher the alpha, the more symmetric the distribution.

alpha ~ dnUniform(0, 1E8)
gamma_rates := fnDiscretizeGamma(alpha, alpha, 4, false)
# 4 is the number of discrete rate categories.
# alpha, alpha specifies the distribution parameters; we assume the shape parameter alpha equals the rate parameter beta, and we the distribution consequently is centered at 1.0
moves.append(mvScale(alpha, lambda=0.1, tune=false, weight=4.0))

#######################################

####################################
###        Invariant Sites         #
####################################

pinvar ~ dnBeta(10,10)
# this results in a uniform distribution; we can increase the value of the parameters alpha and beta (1,1 in this case) to make the probability mass more centered on on the mean.
moves.append( mvBetaProbability(pinvar, delta=10.0, tune=true, weight=2.0) )

#pinvar = probability of an invariant site
####################################

# specify a rate multiplier for each partition
#part_rate_mult ~ dnDirichlet( rep(10.0, 3) )
#moves.append( mvBetaSimplex(part_rate_mult, alpha=1.0, tune=true, weight=3) )
#moves.append( mvDirichletSimplex(part_rate_mult, alpha=1.0, tune=true, weight=2.0) )

# Note that here we are dividing two vectors element-wise, i.e.,
# each element of part_rate_mult gets divided by the corresponding
# element of num_sites. Then we multiply the result by sum(num_sites),
# which is just a scalar. This operation ensures that the mean of
# partition-specific branch lengths, weighted by the number of sites
# in each partition, stays equal to the branch lengths we are
# actually sampling.

#part_rate := part_rate_mult / num_sites * sum(num_sites)
